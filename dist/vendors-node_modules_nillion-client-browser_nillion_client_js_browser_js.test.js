"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkfun_with_js"] = self["webpackChunkfun_with_js"] || []).push([["vendors-node_modules_nillion-client-browser_nillion_client_js_browser_js"],{

/***/ "./node_modules/nillion-client-browser/nillion_client_js_browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/nillion-client-browser/nillion_client_js_browser.js ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClusterDescriptor: () => (/* binding */ ClusterDescriptor),\n/* harmony export */   LoaderHelper: () => (/* binding */ LoaderHelper),\n/* harmony export */   NillionClient: () => (/* binding */ NillionClient),\n/* harmony export */   NodeKey: () => (/* binding */ NodeKey),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   OperationCost: () => (/* binding */ OperationCost),\n/* harmony export */   PaymentReceipt: () => (/* binding */ PaymentReceipt),\n/* harmony export */   Permissions: () => (/* binding */ Permissions),\n/* harmony export */   PreprocessingProtocolConfig: () => (/* binding */ PreprocessingProtocolConfig),\n/* harmony export */   PriceQuote: () => (/* binding */ PriceQuote),\n/* harmony export */   ProgramBindings: () => (/* binding */ ProgramBindings),\n/* harmony export */   PublicVariable: () => (/* binding */ PublicVariable),\n/* harmony export */   PublicVariables: () => (/* binding */ PublicVariables),\n/* harmony export */   Secret: () => (/* binding */ Secret),\n/* harmony export */   Secrets: () => (/* binding */ Secrets),\n/* harmony export */   UserKey: () => (/* binding */ UserKey),\n/* harmony export */   create_payments_message: () => (/* binding */ create_payments_message),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   initSync: () => (/* binding */ initSync),\n/* harmony export */   worker_entry_point: () => (/* binding */ worker_entry_point)\n/* harmony export */ });\n/* harmony import */ var _snippets_browser_async_executor_b51ed65827bac93b_src_worker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./snippets/browser-async-executor-b51ed65827bac93b/src/worker.js */ \"./node_modules/nillion-client-browser/snippets/browser-async-executor-b51ed65827bac93b/src/worker.js\");\n/* harmony import */ var _snippets_libp2p_wasm_ext_7e5f5edb880ee0f5_src_websockets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./snippets/libp2p-wasm-ext-7e5f5edb880ee0f5/src/websockets.js */ \"./node_modules/nillion-client-browser/snippets/libp2p-wasm-ext-7e5f5edb880ee0f5/src/websockets.js\");\n/* harmony import */ var _snippets_nillion_client_js_browser_b8df49adba379ed0_dist_nilffi_bundle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./snippets/nillion-client-js-browser-b8df49adba379ed0/dist/nilffi.bundle.js */ \"./node_modules/nillion-client-browser/snippets/nillion-client-js-browser-b8df49adba379ed0/dist/nilffi.bundle.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\nlet wasm;\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().slice(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n};\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nconst CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(state => {\n    wasm.__wbindgen_export_3.get(state.dtor)(state.a, state.b)\n});\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_3.get(state.dtor)(a, state.b);\n                CLOSURE_DTORS.unregister(state);\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n    CLOSURE_DTORS.register(real, state, state);\n    return real;\n}\nfunction __wbg_adapter_46(arg0, arg1) {\n    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h6a6820458cd8a104(arg0, arg1);\n}\n\nfunction __wbg_adapter_49(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h065eb4a4eb698be0(arg0, arg1, addHeapObject(arg2));\n}\n\n/**\n* Entry point invoked by the web worker. The passed pointer will be unconditionally interpreted\n* as an `Box::<(WorkerExecutor, Worker)>`.\n* @private\n* @param {number} shared_state_ptr\n*/\nfunction worker_entry_point(shared_state_ptr) {\n    wasm.worker_entry_point(shared_state_ptr);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\nfunction __wbg_adapter_168(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__h7fc24273fa103509(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction passArrayJsValueToWasm0(array, malloc) {\n    const ptr = malloc(array.length * 4, 4) >>> 0;\n    const mem = getUint32Memory0();\n    for (let i = 0; i < array.length; i++) {\n        mem[ptr / 4 + i] = addHeapObject(array[i]);\n    }\n    WASM_VECTOR_LEN = array.length;\n    return ptr;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* @param {PriceQuote} quote\n* @param {string} from_address\n* @param {string} type_url\n* @returns {any}\n*/\nfunction create_payments_message(quote, from_address, type_url) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(quote, PriceQuote);\n        var ptr0 = quote.__destroy_into_raw();\n        const ptr1 = passStringToWasm0(from_address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(type_url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        wasm.create_payments_message(retptr, ptr0, ptr1, len1, ptr2, len2);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nconst ClusterDescriptorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_clusterdescriptor_free(ptr >>> 0));\n/**\n* Cluster descriptor\n*\n* The cluster descriptor contains relevant cluster configuration information.\n* This is the structure returned by the `cluster_information` operation in the client.\n*\n* @hideconstructor\n*/\nclass ClusterDescriptor {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ClusterDescriptor.prototype);\n        obj.__wbg_ptr = ptr;\n        ClusterDescriptorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n            id: this.id,\n            parties: this.parties,\n            prime: this.prime,\n            kappa: this.kappa,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ClusterDescriptorFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_clusterdescriptor_free(ptr);\n    }\n    /**\n    * Cluster identifier\n    * Returns the cluster identifier as a string.\n    * @return {string} The cluster identifier\n    *\n    * @example\n    * const descriptor = await nillionClient.cluster_information();\n    * const id = descriptor.id;\n    * @returns {string}\n    */\n    get id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.clusterdescriptor_id(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Cluster parties\n    * Returns the parties in the cluster.\n    * @return {Object} The parties in the cluster\n    *\n    * @example\n    * const descriptor = await nillionClient.cluster_information();\n    * const parties = descriptor.parties;\n    * @returns {any}\n    */\n    get parties() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.clusterdescriptor_parties(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The prime number to be used in this cluster.\n    * @return {string} The prime number as a string\n    *\n    * @example\n    * const descriptor = await nillionClient.cluster_information();\n    * const prime = descriptor.prime;\n    * @returns {string}\n    */\n    get prime() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.clusterdescriptor_prime(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * The security parameter kappa for this cluster.\n    * @return {number} The security parameter kappa\n    *\n    * @example\n    * const descriptor = await nillionClient.cluster_information();\n    * const kappa = descriptor.kappa;\n    * @returns {number}\n    */\n    get kappa() {\n        const ret = wasm.clusterdescriptor_kappa(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n\nconst LoaderHelperFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_loaderhelper_free(ptr >>> 0));\n/**\n* @private\n*/\nclass LoaderHelper {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(LoaderHelper.prototype);\n        obj.__wbg_ptr = ptr;\n        LoaderHelperFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        LoaderHelperFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_loaderhelper_free(ptr);\n    }\n    /**\n    * @returns {string}\n    */\n    mainJS() {\n        const ret = wasm.loaderhelper_mainJS(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst NillionClientFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_nillionclient_free(ptr >>> 0));\n/**\n* The Nillion Client\n*\n* This is the main interface with the Nillion network.\n* The Nillion Client provides APIs that you can use for:\n* - secure computing in Nillion,\n* - storing programs,\n* - managing secrets, and\n* - managing permissions\n*/\nclass NillionClient {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NillionClientFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nillionclient_free(ptr);\n    }\n    /**\n    * Creates an instance of Nillion Client\n    *\n    * @param {UserKey} user_key - The user private key\n    * @param {NodeKey} node_key - The node private key\n    * @param {Array<string>} bootnodes - The Nillion cluster bootnode websocket multiaddresses. A websocket multiaddress has `/ws` or `/wss` (secure sockets) in the address. Example: \"/ip4/127.0.0.1/tcp/14211/wss/p2p/12D3KooWCAGu6gqDrkDWWcFnjsT9Y8rUzUH8buWjdFcU3TfWRmuN\"\n    *\n    * @example\n    * const user_key = UserKey.generate();\n    * const node_key = NodeKey.from_seed('your-seed-here');\n    * const client = new NillionClient(\n    *     user_key,\n    *     node_key,\n    *     bootnodes,\n    *   );\n    */\n    constructor(user_key, node_key, bootnodes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(user_key, UserKey);\n            var ptr0 = user_key.__destroy_into_raw();\n            _assertClass(node_key, NodeKey);\n            var ptr1 = node_key.__destroy_into_raw();\n            const ptr2 = passArrayJsValueToWasm0(bootnodes, wasm.__wbindgen_malloc);\n            const len2 = WASM_VECTOR_LEN;\n            wasm.nillionclient_new(retptr, ptr0, ptr1, ptr2, len2);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Enable remote logging\n    *\n    * Writes client logs to a websocket that can be accessed in URL: ws://127.0.0.1:11100/logs.\n    * You can use tools like [websocat](https://github.com/vi/websocat) to access and read these logs.\n    *\n    * @example\n    * nillionClient.enable_remote_logging();\n    */\n    static enable_remote_logging() {\n        wasm.nillionclient_enable_remote_logging();\n    }\n    /**\n    * Get the party identifier for the current client.\n    * @return {string} The party identifier for the current client\n    *\n    * @example\n    * const partyId = nillionClient.party_id;\n    */\n    get party_id() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nillionclient_party_id(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * Get the user identifier for the current user.\n    *\n    * @return {string} - The Nillion user identifier for the current user\n    *\n    * @example\n    * const userId = nillionClient.user_id;\n    */\n    get user_id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nillionclient_user_id(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Store a secret on Nillion\n    *\n    * @param {string} cluster_id - The targeted cluster identifier\n    * @param {Secrets} secrets - The collection of secrets to store\n    * @param {Permissions | undefined} permissions - Optional permissions to be associated with the secrets. By default the user has full access to the secret.\n    * @returns {Promise<string>} A store ID that can be used to retrieve the secret.\n    *\n    * @example\n    * const secrets = new Secrets();\n    * secrets.insert('secret1', Secret.new_integer('1'));\n    * const store_id = await nillionClient.store_secrets(cluster_id, secrets);\n    */\n    store_secrets(cluster_id, secrets, permissions, receipt) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(secrets, Secrets);\n        let ptr1 = 0;\n        if (!isLikeNone(permissions)) {\n            _assertClass(permissions, Permissions);\n            ptr1 = permissions.__destroy_into_raw();\n        }\n        _assertClass(receipt, PaymentReceipt);\n        const ret = wasm.nillionclient_store_secrets(this.__wbg_ptr, ptr0, len0, secrets.__wbg_ptr, ptr1, receipt.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Retrieve a secret already stored in Nillion\n    *\n    * @param {string} cluster_id - UUID of the targeted preprocessing cluster\n    * @param {string} store_id - The store secret operation identifier for the secret collection that will be retrieved.\n    * @param {string} secret_id - The secret identifier inside the secrets collection\n    * @return {Promise<Secret>} - The secret identified by `secret_id`\n    *\n    * @example\n    * const secret = await nillionClient.retrieve_secret(cluster_id, store_id, secret_id);\n    */\n    retrieve_secret(cluster_id, store_id, secret_id, receipt) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(store_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(secret_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        _assertClass(receipt, PaymentReceipt);\n        const ret = wasm.nillionclient_retrieve_secret(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, receipt.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Update a secret stored in Nillion\n    *\n    * @param {string} cluster_id - UUID of the targeted preprocessing cluster\n    * @param {string} store_id - The store secret operation identifier for the secret collection that will be updated.\n    * @param {Secrets} secrets - The new secret collection that will replace the existing one\n    * @return {Promise<string>} The unique identifier of the update operation\n    *\n    * @example\n    * const secrets = new Secrets();\n    * secrets.insert('secret1', Secret.new_integer('2'));\n    * const action_id = await nillionClient.update_secrets(cluster_id, store_id, secrets);\n    */\n    update_secrets(cluster_id, store_id, secrets, receipt) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(store_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        _assertClass(secrets, Secrets);\n        _assertClass(receipt, PaymentReceipt);\n        const ret = wasm.nillionclient_update_secrets(this.__wbg_ptr, ptr0, len0, ptr1, len1, secrets.__wbg_ptr, receipt.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Delete secrets collection from the network.\n    *\n    * @param {string} cluster_id - UUID of the targeted preprocessing cluster\n    * @param {string} store_id - The store secret operation identifier for the secret collection that will be deleted.\n    * @return {Promise}\n    *\n    * @example\n    * await nillionClient.delete_secrets(cluster_id, store_id);\n    */\n    delete_secrets(cluster_id, store_id) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(store_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.nillionclient_delete_secrets(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n        return takeObject(ret);\n    }\n    /**\n    * Compute in the Nillion Network. This method invokes the compute operation in Nillion.\n    * It returns a compute ID that can be used by `compute_result` to fetch\n    * the results of this computation.\n    *\n    * @param {string} cluster_id - Identifier of the targeted cluster\n    * @param {ProgramBindings} bindings - The program bindings for the computation\n    * @param {Array.<string>} store_ids - The store IDs of the secrets to use for the computation\n    * @param {Secrets} secrets - Additional secrets to use for the computation\n    * @param {PublicVariables} public_variables - Public variables that are used in the computation.\n    * @return {Promise<Object>} A computation UUID.\n    *\n    * @example\n    * const bindings = new ProgramBindings();\n    * bindings.add_input_party('Party1', '12D3KooWKbs29XBmtXZEFZwHBr39BsgbysPAmAS3RWWdtBBc7joH');\n    * const secrets = new Secrets();\n    * secrets.insert('secret1', Secret.new_integer('1'));\n    * const public_variables = new PublicVariables();\n    * const result_id = await nillionClient.compute(cluster_id, bindings, ['store1'], secrets, public_variables);\n    */\n    compute(cluster_id, bindings, store_ids, secrets, public_variables, receipt) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(bindings, ProgramBindings);\n        const ptr1 = passArrayJsValueToWasm0(store_ids, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        _assertClass(secrets, Secrets);\n        _assertClass(public_variables, PublicVariables);\n        _assertClass(receipt, PaymentReceipt);\n        const ret = wasm.nillionclient_compute(this.__wbg_ptr, ptr0, len0, bindings.__wbg_ptr, ptr1, len1, secrets.__wbg_ptr, public_variables.__wbg_ptr, receipt.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Fetch the result of the compute in the Nillion Network\n    *\n    * @param {string} result_id - The computation UUID returned after calling `compute`\n    * @return {Promise<Object>} - The result of the computation\n    *\n    * @example\n    * const result = await nillionClient.compute_result(result_id);\n    */\n    compute_result(result_id) {\n        const ptr0 = passStringToWasm0(result_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.nillionclient_compute_result(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n    * Retrieve permissions for a group of secrets stored in Nillion.\n    *\n    * @param {string} cluster_id - The identifier of the target cluster\n    * @param {string} store_id - The store secret identifier for the secret collection where the secrets are\n    * @return {Promise<Permissions>} The permissions associated to the secrets\n    *\n    * @example\n    * const permissions = await nillionClient.retrieve_permissions(cluster_id, store_id);\n    */\n    retrieve_permissions(cluster_id, store_id, receipt) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(store_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        _assertClass(receipt, PaymentReceipt);\n        const ret = wasm.nillionclient_retrieve_permissions(this.__wbg_ptr, ptr0, len0, ptr1, len1, receipt.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Update permissions for a group of secrets stored in Nillion.\n    *\n    * @param {string} cluster_id - The identifier of the target cluster\n    * @param {string} store_id - The store secret identifier for the secret collection where the secrets are\n    * @param {Permissions} permissions - The permissions that will replace the existing permissions for the secrets\n    * @return {Promise<String>} The action ID corresponding to the update operation\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * permissions.add_update_permissions([\"user_id\"]);\n    * const action_id = await nillionClient.update_permissions(cluster_id, store_id, permissions);\n    */\n    update_permissions(cluster_id, store_id, permissions, receipt) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(store_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        _assertClass(permissions, Permissions);\n        _assertClass(receipt, PaymentReceipt);\n        const ret = wasm.nillionclient_update_permissions(this.__wbg_ptr, ptr0, len0, ptr1, len1, permissions.__wbg_ptr, receipt.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Store a program in the Nillion Network\n    *\n    * @param {string} cluster_id - UUID of the targeted preprocessing cluster\n    * @param {string} program_name - The name of the program\n    * @param {UInt8Array} program - The compiled nada program in binary format\n    * @return The program ID associated with the program\n    *\n    * @example\n    * const program_id = await nillionClient.store_program(cluster_id, 'program_name', program);\n    */\n    store_program(cluster_id, program_name, program, receipt) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(program_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passArray8ToWasm0(program, wasm.__wbindgen_malloc);\n        const len2 = WASM_VECTOR_LEN;\n        _assertClass(receipt, PaymentReceipt);\n        const ret = wasm.nillionclient_store_program(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, receipt.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Request a price quote for an operation on the network.\n    *\n    * This method asks the network to calculate a price quote for the specified operation. Payment\n    * and submission of the operation is the client's responsibility and must be done before the\n    * quote expires.\n    *\n    * @param {string} cluster_id - UUID of the targeted preprocessing cluster\n    * @param {string} operation - The operation to get a quote for.\n    * @return The price quoted for this operation\n    *\n    * @example\n    *     const secrets = new nillion.Secrets();\n    *     secrets.insert(\"int\", nillion.Secret.new_integer(\"42\"));\n    *\n    *     const operation = nillion.Operation.store_secrets(secrets);\n    *     const quote = await context.client.request_price_quote(\n    *         context.config.cluster_id,\n    *         operation,\n    *     );\n    */\n    request_price_quote(cluster_id, operation) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(operation, Operation);\n        const ret = wasm.nillionclient_request_price_quote(this.__wbg_ptr, ptr0, len0, operation.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns information about a Nillion cluster\n    *\n    * @param {string} cluster_id - Identifier of the target cluster\n    * @return {Promise<ClusterDescriptor>} The cluster descriptor for the given cluster\n    *\n    * @example\n    * const cluster_descriptor = await nillionClient.cluster_information(cluster_id);\n    */\n    cluster_information(cluster_id) {\n        const ptr0 = passStringToWasm0(cluster_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.nillionclient_cluster_information(this.__wbg_ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n    * Enables tracking for the user.\n    *\n    * Enables tracking of client actions (store, retrieve, compute ...)\n    * @return {Promise}\n    *\n    * @example\n    * await nillionClient.enable_tracking();\n    */\n    static enable_tracking(wallet_addr) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(wallet_addr) ? 0 : passStringToWasm0(wallet_addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.nillionclient_enable_tracking(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the build version of the Nillion client.\n    *\n    * @return {string} A string representation of the build version\n    *\n    * @example\n    * const version = nillionClient.build_version;\n    */\n    static get build_version() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.nillionclient_build_version(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst NodeKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_nodekey_free(ptr >>> 0));\n/**\n* Node key\n*\n* The node key is used to authenticate the node in the Nillion network.\n* The key can be generated from a seed or from a base58 string.\n*\n* @hideconstructor\n* @example\n*\n* const key = new NodeKey.from_seed(\"my_seed\");\n*/\nclass NodeKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(NodeKey.prototype);\n        obj.__wbg_ptr = ptr;\n        NodeKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        NodeKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_nodekey_free(ptr);\n    }\n    /**\n    * Generates a private key using a seed.\n    *\n    * @param {string} seed - The seed that will be used to generate the NodeKey\n    * @return {NodeKey} A NodeKey\n    *\n    * @example\n    *\n    * const key = new NodeKey.from_seed(\"my_seed\");\n    */\n    static from_seed(seed) {\n        const ptr0 = passStringToWasm0(seed, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.nodekey_from_seed(ptr0, len0);\n        return NodeKey.__wrap(ret);\n    }\n    /**\n    * Decodes a private key from a string encoded in Base58.\n    *\n    * @param {string} contents - A base58 string\n    * @return {NodeKey} An instance of NodeKey matching the string provided\n    *\n    * @example\n    *\n    * const key = new NodeKey.from_base58(<base 58 encoded data>);\n    */\n    static from_base58(contents) {\n        const ptr0 = passStringToWasm0(contents, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.nodekey_from_base58(ptr0, len0);\n        return NodeKey.__wrap(ret);\n    }\n}\n\nconst OperationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_operation_free(ptr >>> 0));\n/**\n* Operation.\n*\n* This type represents an operation to be run on the Nillion network.\n*\n* @hideconstructor\n*/\nclass Operation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Operation.prototype);\n        obj.__wbg_ptr = ptr;\n        OperationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OperationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_operation_free(ptr);\n    }\n    /**\n    * Create a new store secrets operation.\n    *\n    * @param {Secrets} secrets - The secrets to be stored.\n    * @return {Operation} - The constructed operation.\n    *\n    * @example\n    * const operation = Operation.store_secrets(secrets);\n    * @param {Secrets} secrets\n    * @returns {Operation}\n    */\n    static store_secrets(secrets) {\n        _assertClass(secrets, Secrets);\n        const ret = wasm.operation_store_secrets(secrets.__wbg_ptr);\n        return Operation.__wrap(ret);\n    }\n    /**\n    * Create a new update secrets operation.\n    *\n    * @param {Secrets} secrets - The secrets to be updated.\n    * @return {Operation} - The constructed operation.\n    *\n    * @example\n    * const operation = Operation.update_secrets(secrets);\n    * @param {Secrets} secrets\n    * @returns {Operation}\n    */\n    static update_secrets(secrets) {\n        _assertClass(secrets, Secrets);\n        const ret = wasm.operation_update_secrets(secrets.__wbg_ptr);\n        return Operation.__wrap(ret);\n    }\n    /**\n    * Create a new compute operation.\n    *\n    * @param {string} program_id - The program id to be used.\n    * @param {Secrets} secrets - The secrets to be used as compute secrets.\n    * @return {Operation} - The constructed operation.\n    *\n    * @example\n    * const operation = Operation.compute(secrets);\n    * @param {string} program_id\n    * @param {Secrets} secrets\n    * @returns {Operation}\n    */\n    static compute(program_id, secrets) {\n        const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(secrets, Secrets);\n        const ret = wasm.operation_compute(ptr0, len0, secrets.__wbg_ptr);\n        return Operation.__wrap(ret);\n    }\n    /**\n    * Create a new retrieve secret operation.\n    *\n    * @return {Operation} - The constructed operation.\n    *\n    * @example\n    * const operation = Operation.retrieve_secret();\n    * @returns {Operation}\n    */\n    static retrieve_secret() {\n        const ret = wasm.operation_retrieve_secret();\n        return Operation.__wrap(ret);\n    }\n    /**\n    * Create a new store program operation.\n    *\n    * @return {Operation} - The constructed operation.\n    *\n    * @example\n    * const operation = Operation.store_program();\n    * @returns {Operation}\n    */\n    static store_program() {\n        const ret = wasm.operation_store_program();\n        return Operation.__wrap(ret);\n    }\n    /**\n    * Create a new retrieve permissions operation.\n    *\n    * @return {Operation} - The constructed operation.\n    *\n    * @example\n    * const operation = Operation.retrieve_permissions();\n    * @returns {Operation}\n    */\n    static retrieve_permissions() {\n        const ret = wasm.operation_retrieve_permissions();\n        return Operation.__wrap(ret);\n    }\n    /**\n    * Create a new update permissions operation.\n    *\n    * @return {Operation} - The constructed operation.\n    *\n    * @example\n    * const operation = Operation.update_permissions();\n    * @returns {Operation}\n    */\n    static update_permissions() {\n        const ret = wasm.operation_update_permissions();\n        return Operation.__wrap(ret);\n    }\n}\n\nconst OperationCostFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_operationcost_free(ptr >>> 0));\n/**\n*/\nclass OperationCost {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(OperationCost.prototype);\n        obj.__wbg_ptr = ptr;\n        OperationCostFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n            base_fee: this.base_fee,\n            congestion_fee: this.congestion_fee,\n            total: this.total,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        OperationCostFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_operationcost_free(ptr);\n    }\n    /**\n    * Gets the cost of the base fee in unil units.\n    *\n    * @return {string} - The base fee for this quote.\n    *\n    * @example\n    *     const base_fee = cost.base_fee\n    */\n    get base_fee() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationcost_base_fee(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Gets the cost of the congestion fee in unil units.\n    *\n    * @return {string} - The congestion fee for this quote.\n    *\n    * @example\n    *     const congestion_fee = cost.congestion_fee\n    */\n    get congestion_fee() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationcost_congestion_fee(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Gets the total cost of the quote in unil units.\n    * The payment associated for the quoted operation must\n    * transfer this amount for it to be considered a valid\n    * payment.\n    *\n    * @return {string} - The total cost for this quote.\n    *\n    * @example\n    *     const total = cost.total\n    */\n    get total() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.operationcost_total(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nconst PaymentReceiptFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_paymentreceipt_free(ptr >>> 0));\n/**\n* Payment receipt.\n*\n* This type represents a payment receipt for an operation in the Nillion network.\n*\n* @hideconstructor\n*/\nclass PaymentReceipt {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PaymentReceiptFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_paymentreceipt_free(ptr);\n    }\n    /**\n    * Creates an instance of a payment receipt\n    *\n    * @param {PriceQuote} quote - The price quote this receipt is for\n    * @param {string} transaction_hash - The hash of the transaction in which the payment was\n    * made.\n    */\n    constructor(quote, transaction_hash) {\n        _assertClass(quote, PriceQuote);\n        const ptr0 = passStringToWasm0(transaction_hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.paymentreceipt_new(quote.__wbg_ptr, ptr0, len0);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n\nconst PermissionsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_permissions_free(ptr >>> 0));\n/**\n* The permissions data structure.\n*\n* In Nillion, every stored secret has associated a set of permissions upon creation.\n* If no permissions are provided, the network will grant ownership as well as update, delete and retrieve permissions\n* to the user storing the secret.\n*\n* For each compute operation, the secrets need to have granted compute permissions for the program and the user\n* accessing the secret for the purpose of a computation.\n*\n* Permissions for any store secret can be updated and retrieved by the owner using `update_permissions` and `retrieve_permissions` operations\n* respectively.\n*/\nclass Permissions {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Permissions.prototype);\n        obj.__wbg_ptr = ptr;\n        PermissionsFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PermissionsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_permissions_free(ptr);\n    }\n    /**\n    * Build a new empty instance of Permissions\n    *\n    * @example\n    * const permissions = new Permissions();\n    */\n    constructor() {\n        const ret = wasm.permissions_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Builds a new instance of Permissions with the default set for the user identifier.\n    *\n    * By default, the user identifier will be granted ownership of the secret as well as full access to the secret.\n    * No compute permissions are granted by default unless a program is specified. They need to be assigned separately.\n    *\n    * @param {string} user_id - The Nillion user identifier\n    * @returns {Permissions} An instance of Permissions with the default configuration for the user\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    */\n    static default_for_user(user_id) {\n        const ptr0 = passStringToWasm0(user_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.permissions_default_for_user(ptr0, len0);\n        return Permissions.__wrap(ret);\n    }\n    /**\n    * Add retrieve permissions to the Permissions instance for the\n    * given list of user IDs\n    *\n    * @param {Array<string>} user_ids - The list of user identifiers that will be granted retrieve permissions\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * permissions.add_retrieve_permissions([\"user_id\"]);\n    */\n    add_retrieve_permissions(user_ids) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(user_ids, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.permissions_add_retrieve_permissions(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add update permissions to the Permissions instance for the\n    * given list of user IDs\n    *\n    * @param {Array<string>} user_ids - The list of user identifiers that will be granted update permissions\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * permissions.add_update_permissions([\"user_id\"]);\n    */\n    add_update_permissions(user_ids) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(user_ids, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.permissions_add_update_permissions(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add delete permissions to the Permissions instance for the\n    * given list of user IDs\n    *\n    * @param {Array<string>} user_ids - The list of user identifiers that will be granted delete permissions\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * permissions.add_delete_permissions([\"user_id\"]);\n    */\n    add_delete_permissions(user_ids) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArrayJsValueToWasm0(user_ids, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.permissions_add_delete_permissions(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add compute permissions to the Permissions instance for the\n    * given list of user IDs\n    *\n    * @param {any} permissions - object where the keys are the user identities and for each key the values are a list of program identifiers that\n    *     user will be granted compute permission for.\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * permissions.add_compute_permissions({\n    *     \"user_id\": [\"program_id\"]\n    * });\n    */\n    add_compute_permissions(permissions) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.permissions_add_compute_permissions(retptr, this.__wbg_ptr, addHeapObject(permissions));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns true if user has retrieve permissions\n    *\n    * @param {string} user_id - the user identifier\n    * @return {boolean} true if the user has retrieve permissions\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * const retrieve_allowed = permissions.is_retrieve_allowed(\"user_id\");\n    */\n    is_retrieve_allowed(user_id) {\n        const ptr0 = passStringToWasm0(user_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.permissions_is_retrieve_allowed(this.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * Returns true if user has update permissions\n    *\n    * @param {string} user_id - the user identifier\n    * @return {boolean} true if the user has update permissions\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * const update_allowed = permissions.is_update_allowed(\"user_id\");\n    */\n    is_update_allowed(user_id) {\n        const ptr0 = passStringToWasm0(user_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.permissions_is_update_allowed(this.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * Returns true if user has delete permissions\n    *\n    * @param {string} user_id - the user identifier\n    * @return {boolean} true if the user has delete permissions\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * const delete_allowed = permissions.is_delete_allowed(\"user_id\");\n    */\n    is_delete_allowed(user_id) {\n        const ptr0 = passStringToWasm0(user_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.permissions_is_delete_allowed(this.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * Returns true if user has compute permissions for every single program\n    *\n    * @param {string} user_id - the user identifier\n    * @param {string} program - the program identifier\n    * @return {boolean} true if the user has compute permissions\n    *\n    * @example\n    * const permissions = Permissions.default_for_user(nillionClient.user_id);\n    * const compute_allowed = permissions.is_compute_allowed(\"user_id\", \"program_id\");\n    */\n    is_compute_allowed(user_id, program) {\n        const ptr0 = passStringToWasm0(user_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.permissions_is_compute_allowed(this.__wbg_ptr, ptr0, len0, ptr1, len1);\n        return ret !== 0;\n    }\n}\n\nconst PreprocessingProtocolConfigFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_preprocessingprotocolconfig_free(ptr >>> 0));\n/**\n* The pre-processing protocol configuration\n* @hideconstructor\n*/\nclass PreprocessingProtocolConfig {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PreprocessingProtocolConfigFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_preprocessingprotocolconfig_free(ptr);\n    }\n    /**\n    * The number of elements to be generated on every run.\n    *\n    * @example\n    * const descriptor = await nillionClient.cluster_information();\n    * const preprocessing = descriptor.preprocessing;\n    * const lambda = preprocessing.lambda;\n    * const batch_size = lambda.batch_size;\n    * @returns {number}\n    */\n    get batch_size() {\n        const ret = wasm.preprocessingprotocolconfig_batch_size(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n\nconst PriceQuoteFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_pricequote_free(ptr >>> 0));\n/**\n* Price quote.\n*\n* This type represents a price quote for an operation in the Nillion network.\n*\n* @hideconstructor\n*/\nclass PriceQuote {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PriceQuote.prototype);\n        obj.__wbg_ptr = ptr;\n        PriceQuoteFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n            expires_at: this.expires_at,\n            cost: this.cost,\n            nonce: this.nonce,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PriceQuoteFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_pricequote_free(ptr);\n    }\n    /**\n    * Get the expiration time for this price quote.\n    *\n    * The payment and the operation execution must be invoked before this deadline is\n    * hit, otherwise the network will reject the operation request.\n    *\n    * @return {Date} - The expiration time.\n    *\n    * @example\n    * const expiration_time = quote.expires_at;\n    */\n    get expires_at() {\n        const ret = wasm.pricequote_expires_at(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Gets the cost for the quoted operation in unil units. The payment associated for the quoted operation must\n    * transfer this amount for it to be considered a valid payment.\n    *\n    * @return {OperationCost} - The cost for this quote.\n    *\n    * @example\n    * const cost = quote.cost;\n    */\n    get cost() {\n        const ret = wasm.pricequote_cost(this.__wbg_ptr);\n        return OperationCost.__wrap(ret);\n    }\n    /**\n    * Gets the nonce for this quote. This nonce must be used as part of the payment transaction.\n    *\n    * @example\n    * const nonce = quote.nonce;\n    */\n    get nonce() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.pricequote_nonce(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst ProgramBindingsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_programbindings_free(ptr >>> 0));\n/**\n* Program Bindings\n*/\nclass ProgramBindings {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        ProgramBindingsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_programbindings_free(ptr);\n    }\n    /**\n    * Creates a new ProgramBindings\n    *\n    * @param {string} program_id - A program identifier, this is usually the given name of the program\n    * @return {ProgramBindings} A new instance of ProgramBindings\n    *\n    * @example\n    * const bindings = new ProgramBindings(\"simple_program\");\n    */\n    constructor(program_id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.programbindings_new(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Bind an input party with a name\n    *\n    * @param {string} name - Name of the input party\n    * @param {string} id - Identifier of the party\n    *\n    * @example\n    * bindings.add_input_party(\"Party1\", \"12D3KooWKbs29XBmtXZEFZwHBr39BsgbysPAmAS3RWWdtBBc7joH\");\n    */\n    add_input_party(name, id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.programbindings_add_input_party(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Bind an output party with a name\n    *\n    * @param {string} name - Name of the input party\n    * @param {string} id - Identifier of the party\n    *\n    * @example\n    * bindings.add_output_party(\"Party2\", \"12D3KooWKbs29XBmtXZEFZwHBr39BsgbysPAmAS3RWWdtBBc7joH\");\n    */\n    add_output_party(name, id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.programbindings_add_output_party(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst PublicVariableFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_publicvariable_free(ptr >>> 0));\n/**\n* Public Variable.\n*\n* This type represents a public variable in the Nillion network.\n* Public variables can be provided as part of program inputs, as well as secrets.\n*\n* @hideconstructor\n*/\nclass PublicVariable {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PublicVariable.prototype);\n        obj.__wbg_ptr = ptr;\n        PublicVariableFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PublicVariableFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publicvariable_free(ptr);\n    }\n    /**\n    * Create a new public integer with the provided value.\n    *\n    * @param {string} value - The value must be a valid string representation of an integer.\n    * @return {PublicVariable} The encoded public variable corresponding to the value provided\n    *\n    * @example\n    * const public_variable = PublicVariable.new_integer(\"-23\");\n    */\n    static new_integer(value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.publicvariable_new_integer(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicVariable.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a new public unsigned integer with the provided value.\n    *\n    * @param {string} value - The value must be a valid string representation of an unsigned integer.\n    * @return {PublicVariable} The encoded public variable corresponding to the value provided\n    *\n    * @example\n    * const public_variable = PublicVariable.new_unsigned_integer(\"23\");\n    */\n    static new_unsigned_integer(value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.publicvariable_new_unsigned_integer(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PublicVariable.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Convert this public variable into a string representation of the underlying numeric value.\n    *\n    * This only works for numeric public variables, such as integers and unsigned integers.\n    * @return {string} The string representation of the numeric value contained in the public variable.\n    *\n    * @example\n    * const public_variable = PublicVariable.new_integer(\"-23\");\n    * const value = public_variable.to_integer();\n    */\n    to_integer() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publicvariable_to_integer(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\n\nconst PublicVariablesFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_publicvariables_free(ptr >>> 0));\n/**\n* Public variables\n*\n* A collection of named public variables\n*/\nclass PublicVariables {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PublicVariablesFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_publicvariables_free(ptr);\n    }\n    /**\n    * Creates a new instance of PublicVariables without values.\n    * @return {PublicVariables} The new instance of PublicVariables\n    *\n    * @example\n    * const publicVariables = new PublicVariables();\n    */\n    constructor() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publicvariables_new(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add encoded public variable to the PublicVariables collection.\n    * @param {string} name - The name of the public variable\n    * @param {PublicVariable} input - The public variable to add\n    *\n    * @example\n    * publicVariables.insert(\"my_integers\", PublicVariable.new_integer(\"23\"));\n    */\n    insert(name, input) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(input, PublicVariable);\n        wasm.publicvariables_insert(this.__wbg_ptr, ptr0, len0, input.__wbg_ptr);\n    }\n    /**\n    * Get the number of public variables.\n    * @return {number} The number of public variables in the collection\n    *\n    * @example\n    * const length = publicVariables.length;\n    * @returns {number}\n    */\n    get length() {\n        const ret = wasm.publicvariables_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n\nconst SecretFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_secret_free(ptr >>> 0));\n/**\n* Secret\n*\n* This type represents a secret in the Nillion network. This class provides utilities\n* to encode numerical and binary values into secrets. It also provides methods to decode\n* the secret into a numerical value.\n*\n* @hideconstructor\n*/\nclass Secret {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Secret.prototype);\n        obj.__wbg_ptr = ptr;\n        SecretFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SecretFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secret_free(ptr);\n    }\n    /**\n    * Create a new secret integer with the provided value.\n    *\n    * @param {string} value - The value must be a valid string representation of an integer.\n    * @return {Secret} The encoded secret corresponding to the value provided\n    *\n    * @example\n    * const secret = Secret.new_integer(\"-23\");\n    */\n    static new_integer(value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.secret_new_integer(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Secret.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a new secret unsigned integer with the provided value.\n    *\n    * @param {string} value - The value must be a valid string representation of an unsigned integer.\n    * @return {Secret} The encoded secret corresponding to the value provided\n    *\n    * @example\n    * const secret = Secret.new_integer(\"23\");\n    */\n    static new_unsigned_integer(value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.secret_new_unsigned_integer(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Secret.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a new non-zero secret integer with the provided value.\n    *\n    * @param {string} value - The value must be a valid string representation of an integer.\n    * @return {Secret} The encoded secret corresponding to the value provided\n    *\n    * @example\n    * const secret = Secret.new_non_zero_integer(\"-23\");\n    */\n    static new_non_zero_integer(value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.secret_new_non_zero_integer(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Secret.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a new secret unsigned integer with the provided value.\n    *\n    * @param {string} value - The value must be a valid string representation of an unsigned integer.\n    * @return {Secret} The encoded secret corresponding to the value provided\n    *\n    * @example\n    * const secret = Secret.new_non_zero_unsigned_integer(\"23\");\n    */\n    static new_non_zero_unsigned_integer(value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.secret_new_non_zero_unsigned_integer(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Secret.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a new secret blob with the provided value.\n    *\n    * @param {Uint8Array} value - The blob in binary (byte array) encoded format\n    * @return {Secret} The encoded secret corresponding to the value provided\n    *\n    * @example\n    * const secret = Secret.new_blob([1,0,1,222,21]);\n    */\n    static new_blob(value) {\n        const ptr0 = passArray8ToWasm0(value, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.secret_new_blob(ptr0, len0);\n        return Secret.__wrap(ret);\n    }\n    /**\n    * Convert this secret into a byte array.\n    *\n    * This is only valid for blob secrets.\n    * @return {Uint8Array} the byte array contained in this secret.\n    * @throws {Error} if the secret is not a blob.\n    *\n    * @example\n    * const secret = Secret.new_blob([1,0,1,222,21]);\n    * const byteArray = secret.to_byte_array();\n    */\n    to_byte_array() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secret_to_byte_array(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Convert this secret into a string representation of the underlying numeric value.\n    *\n    * This only works for numeric secrets, such as integers and unsigned integers.\n    * @return {string} a string representation of the underlying numeric value of this secret\n    *\n    * @example\n    * const secret = Secret.new_integer(\"23\");\n    * const value = secret.to_integer();\n    */\n    to_integer() {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.secret_to_integer(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n}\n\nconst SecretsFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_secrets_free(ptr >>> 0));\n/**\n* A collection of named secrets.\n*/\nclass Secrets {\n\n    toJSON() {\n        return {\n            length: this.length,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SecretsFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_secrets_free(ptr);\n    }\n    /**\n    * Creates a new instance of Secrets without values.\n    *\n    * @example\n    * const secrets = new Secrets();\n    */\n    constructor() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.publicvariables_new(retptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            this.__wbg_ptr = r0 >>> 0;\n            return this;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add encoded secret to Secrets collection.\n    *\n    * @param {string} name - The name of the secret\n    * @param {Secret} input - The secret to be added\n    *\n    * @example\n    * secrets.insert(\"my_secret\", Secret.new_integer(\"23\"));\n    */\n    insert(name, input) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(input, Secret);\n        wasm.secrets_insert(this.__wbg_ptr, ptr0, len0, input.__wbg_ptr);\n    }\n    /**\n    * Get the number of secrets.\n    *\n    * @example\n    * const length = secrets.length;\n    * @returns {number}\n    */\n    get length() {\n        const ret = wasm.publicvariables_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n\nconst UserKeyFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_userkey_free(ptr >>> 0));\n/**\n* User key\n*\n* The user key is used as the user identity in the Nillion network.\n* The key can be generated from a seed or from a base58 string.\n*\n* @hideconstructor\n* @example\n*\n* const key = new UserKey.from_seed(\"my_seed\");\n*/\nclass UserKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(UserKey.prototype);\n        obj.__wbg_ptr = ptr;\n        UserKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        UserKeyFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_userkey_free(ptr);\n    }\n    /**\n    * Generate a new random public/private key.\n    * Uses a cryptographically secure pseudo-random number generator.\n    *\n    * @return {UserKey} a new instance of UserKey\n    *\n    * @example\n    *\n    * const key = new UserKey.generate();\n    */\n    static generate() {\n        const ret = wasm.userkey_generate();\n        return UserKey.__wrap(ret);\n    }\n    /**\n    * Generate a new public/private key.\n    * Uses a seed to generate the keys via a cryptographically secure pseudo-random number generator.\n    *\n    * @param {string} seed - The seed that will be used to generate the key\n    *\n    * @return {UserKey} The user key generated using the seed provided\n    *\n    * @example\n    *\n    * const key = new UserKey.from_seed(\"my_seed\");\n    */\n    static from_seed(seed) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(seed, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.userkey_from_seed(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UserKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the public key corresponding to this key.\n    *\n    * @return {string} The public key as an UTF-8 encoded string.\n    *\n    * @example\n    *\n    * const key = new UserKey.from_seed(\"my_seed\");\n    * const public_key = key.public_key();\n    */\n    public_key() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.userkey_public_key(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Decodes a UserKey from a Base58-encoded String\n    *\n    * @param {string} contents - The private key encoded in Base58 format\n    * @return {UserKey} The decoded instance of UserKey\n    *\n    * @example\n    *\n    * const key = new UserKey.from_base58(<base 58 encoded data>);\n    */\n    static from_base58(contents) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(contents, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.userkey_from_base58(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return UserKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the key in Base58 encoded form.\n    *\n    * @return {string} the key encoded as a Base58 string\n    * @example\n    *\n    * const key = new UserKey.from_seed(\"my_seed\");\n    * const base58_key = key.to_base58();\n    */\n    to_base58() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.userkey_to_base58(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_new_72fb9a18b5ae2624 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_1f9b04f170055d33 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_module = function() {\n        const ret = __wbg_init.__wbindgen_wasm_module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_startWorker_999d186cbabd739c = function(arg0, arg1, arg2, arg3, arg4) {\n        const ret = (0,_snippets_browser_async_executor_b51ed65827bac93b_src_worker_js__WEBPACK_IMPORTED_MODULE_0__.startWorker)(takeObject(arg0), takeObject(arg1), takeObject(arg2), takeObject(arg3), LoaderHelper.__wrap(arg4));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_name_c1b921b610dd2f64 = function(arg0, arg1) {\n        const ret = getObject(arg1).name;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_close_e37e2399b189a4cd = function(arg0) {\n        getObject(arg0).close();\n    };\n    imports.wbg.__wbg_static_accessor_URL_1a7ae0d56f4d6839 = function() {\n        const ret = \"file:///Users/tim/projects/tim-hm/fun-with-js/node_modules/nillion-client-browser/nillion_client_js_browser.js\";\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new0_7d84e5b2cd9fdc73 = function() {\n        const ret = new Date();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getTime_2bc4375165f02d15 = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbg_getItem_164e8e5265095b87 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg1).getItem(getStringFromWasm0(arg2, arg3));\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Window_f401953a2cf86220 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Window;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_localStorage_e381d34d0c40c761 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).localStorage;\n        return isLikeNone(ret) ? 0 : addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setItem_ba2bb41d73dac079 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).setItem(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_abort_2aa7521d5690750e = function(arg0) {\n        getObject(arg0).abort();\n    };\n    imports.wbg.__wbg_new_ab6fd82b10560829 = function() { return handleError(function () {\n        const ret = new Headers();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_0d76b0581eca6298 = function() { return handleError(function () {\n        const ret = new AbortController();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_signal_a61f78a3478fd9bc = function(arg0) {\n        const ret = getObject(arg0).signal;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_append_7bfcb4937d1d5e29 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Response_849eb93e75734b6e = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_status_61a01141acd3cf74 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_headers_9620bfada380764a = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_196c84450b364254 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_298b57d23c0fc80c = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_d93c65011f51a456 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stringify_8887fe74e1c50d81 = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_text_450a059667fd91fd = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).text();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_abda76e883ba8a5f = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_buffer_12d079cc21e14bdb = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_5c9c955aa56b6049 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_subarray_a1f73cd4b5b42fe1 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_3aa56aa6edec874c = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_new_63b92bc8671ed464 = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_crypto_1d1f22824a6a080c = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_process_4a72847cc503995b = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_f686565e586dd935 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_104a2ff8d6ea03a2 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_require_cca90b1a94a0255b = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_call_b3ca7c6051f9bec1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_msCrypto_eb05e62b530a1508 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_e9b4878cebadb3d3 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() {\n        const ret = module;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_code_5ee5dcc2842228cd = function(arg0) {\n        const ret = getObject(arg0).code;\n        return ret;\n    };\n    imports.wbg.__wbg_reason_5ed6709323849cb1 = function(arg0, arg1) {\n        const ret = getObject(arg1).reason;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_wasClean_8222e9acf5c5ad07 = function(arg0) {\n        const ret = getObject(arg0).wasClean;\n        return ret;\n    };\n    imports.wbg.__wbg_data_3ce7c145ca4fbcdc = function(arg0) {\n        const ret = getObject(arg0).data;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_836825be07d4c9d2 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_send_70603dff16b81b66 = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).send(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_send_5fcd7bab9777194e = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).send(getArrayU8FromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Error_e20bb56fd5591a93 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Error;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_name_e7429f0dda6079e2 = function(arg0) {\n        const ret = getObject(arg0).name;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_message_5bf28016c2b49cfb = function(arg0) {\n        const ret = getObject(arg0).message;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_toString_ffe4c9ea3b3532e9 = function(arg0) {\n        const ret = getObject(arg0).toString();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_setTimeout_75cb9b6991a4031d = function() { return handleError(function (arg0, arg1) {\n        const ret = setTimeout(getObject(arg0), arg1);\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_get_e3c254076557e348 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_now_4e659b3d15f470d9 = function(arg0) {\n        const ret = getObject(arg0).now();\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_2cee6dadfd956dfa = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_27c0f87801dedf93 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_next_40fc327bfc8770e6 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_c20a40f15020d68a = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_self_ce0dbfc45cf2f5be = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_c6fb939a7f436783 = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_d1e6af4856ba331b = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_207b558942527489 = function() { return handleError(function () {\n        const ret = __webpack_require__.g.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_newnoargs_e258087cd0daa0ea = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_clearTimeout_76877dbc010e786d = function(arg0) {\n        const ret = clearTimeout(takeObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_dial_30e8812bd98d8882 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).dial(getStringFromWasm0(arg1, arg2), arg3 !== 0);\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbg_write_3d1f2c679934dd25 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).write(getArrayU8FromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_shutdown_a85687f76230bdad = function() { return handleError(function (arg0) {\n        getObject(arg0).shutdown();\n    }, arguments) };\n    imports.wbg.__wbg_close_6a852f1689b0b8e2 = function(arg0) {\n        getObject(arg0).close();\n    };\n    imports.wbg.__wbg_instanceof_Object_71ca3c0a59266746 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Object;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_toString_c816a20ab859d0c1 = function(arg0) {\n        const ret = getObject(arg0).toString();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_secret_new = function(arg0) {\n        const ret = Secret.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_permissions_new = function(arg0) {\n        const ret = Permissions.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_clusterdescriptor_new = function(arg0) {\n        const ret = ClusterDescriptor.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_d9bc3a0147634640 = function() {\n        const ret = new Map();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fromEntries_c9d8ec8925e677a8 = function() { return handleError(function (arg0) {\n        const ret = Object.fromEntries(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_set_8417257aaedc936b = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_pricequote_new = function(arg0) {\n        const ret = PriceQuote.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_16b304a2cfa7ff4a = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_d4638f722068f043 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_new_6c74223c77cfabad = function() { return handleError(function (arg0, arg1) {\n        const ret = new WebSocket(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setbinaryType_b0cf5103cd561959 = function(arg0, arg1) {\n        getObject(arg0).binaryType = takeObject(arg1);\n    };\n    imports.wbg.__wbg_addEventListener_4283b15b4f039eb5 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3), getObject(arg4));\n    }, arguments) };\n    imports.wbg.__wbg_addEventListener_53b787075bd5e003 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        getObject(arg0).addEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3));\n    }, arguments) };\n    imports.wbg.__wbg_error_8e3928cfb8a43e2b = function(arg0) {\n        console.error(getObject(arg0));\n    };\n    imports.wbg.__wbg_new_81740750da40724f = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_168(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_get_bd8e338fbd5f5cc8 = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_entries_95cc2c823b285a09 = function(arg0) {\n        const ret = Object.entries(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_cd7af8117672b8b8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_crypto_c909fb428dcbddb6 = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_getRandomValues_307049345d0bd88c = function(arg0) {\n        const ret = getObject(arg0).getRandomValues;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) {\n        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n    };\n    imports.wbg.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    };\n    imports.wbg.__wbg_new_cf3ec55744a78578 = function(arg0) {\n        const ret = new Date(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_f975102236d3c502 = function(arg0, arg1, arg2) {\n        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_createPaymentsMessage_9d93aaf669e28bfa = function(arg0, arg1, arg2) {\n        const ret = (0,_snippets_nillion_client_js_browser_b8df49adba379ed0_dist_nilffi_bundle_js__WEBPACK_IMPORTED_MODULE_1__.createPaymentsMessage)(takeObject(arg0), takeObject(arg1), takeObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_66ae46612e7f0234 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_str = function(arg0, arg1) {\n        const ret = BigInt(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_isArray_2ab64d95e09ea0ae = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_newaddrs_71100193fa47c194 = function(arg0, arg1) {\n        const ret = getObject(arg1).new_addrs;\n        var ptr1 = isLikeNone(ret) ? 0 : passArrayJsValueToWasm0(ret, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_newconnections_44d312e897866295 = function(arg0, arg1) {\n        const ret = getObject(arg1).new_connections;\n        var ptr1 = isLikeNone(ret) ? 0 : passArrayJsValueToWasm0(ret, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_localaddr_91f6c1af88a435e2 = function(arg0, arg1) {\n        const ret = getObject(arg1).local_addr;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_observedaddr_1ca1352afe737cc2 = function(arg0, arg1) {\n        const ret = getObject(arg1).observed_addr;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_connection_632aa60cbc9cffe2 = function(arg0) {\n        const ret = getObject(arg0).connection;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_read_c68b57fe8b00a7b9 = function(arg0) {\n        const ret = getObject(arg0).read;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_expiredaddrs_c5a2f22f3c1b584f = function(arg0, arg1) {\n        const ret = getObject(arg1).expired_addrs;\n        var ptr1 = isLikeNone(ret) ? 0 : passArrayJsValueToWasm0(ret, wasm.__wbindgen_malloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_listenon_ff60af88e263af6b = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).listen_on(getStringFromWasm0(arg1, arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_websockettransport_84c8ba3f0c468e40 = function() {\n        const ret = (0,_snippets_libp2p_wasm_ext_7e5f5edb880ee0f5_src_websockets_js__WEBPACK_IMPORTED_MODULE_2__.websocket_transport)();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_has_0af94d20077affa2 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.has(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_fetch_bc7c8e27076a5c84 = function(arg0) {\n        const ret = fetch(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_921fad6ef9e883dd = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_2b3bbecd033d19f6 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_String_b9412f8799faab3e = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_rethrow = function(arg0) {\n        throw takeObject(arg0);\n    };\n    imports.wbg.__wbg_queueMicrotask_3cbae2ec6b6cd3d6 = function(arg0) {\n        const ret = getObject(arg0).queueMicrotask;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_resolve_b0083a7967828ec8 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_a73caa9a87991566 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_link_fc1eedd35dc7e0a6 = function(arg0) {\n        const ret = \"data:application/javascript,\" + encodeURIComponent(`onmessage = function (ev) {\n            let [ia, index, value] = ev.data;\n            ia = new Int32Array(ia.buffer);\n            let result = Atomics.wait(ia, index, value);\n            postMessage(result);\n        };\n        `);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_new_d1187ae36d662ef9 = function() { return handleError(function (arg0, arg1) {\n        const ret = new Worker(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_setonmessage_503809e5bb51bd33 = function(arg0, arg1) {\n        getObject(arg0).onmessage = getObject(arg1);\n    };\n    imports.wbg.__wbg_of_6a70eed8d41f469c = function(arg0, arg1, arg2) {\n        const ret = Array.of(getObject(arg0), getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_postMessage_7380d10e8b8269df = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).postMessage(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_waitAsync_5d743fc9058ba01a = function() {\n        const ret = Atomics.waitAsync;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_8cccba86b0f574cb = function(arg0) {\n        const ret = new Int32Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_waitAsync_46d5c36955b71a79 = function(arg0, arg1, arg2) {\n        const ret = Atomics.waitAsync(getObject(arg0), arg1, arg2);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_async_19c0400d97cc72fe = function(arg0) {\n        const ret = getObject(arg0).async;\n        return ret;\n    };\n    imports.wbg.__wbg_value_571d60108110e917 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_0c86a60e8fcfe9f6 = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_queueMicrotask_481971b0d87f3dd4 = function(arg0) {\n        queueMicrotask(getObject(arg0));\n    };\n    imports.wbg.__wbg_readyState_1c157e4ea17c134a = function(arg0) {\n        const ret = getObject(arg0).readyState;\n        return ret;\n    };\n    imports.wbg.__wbg_close_acd9532ff5c093ea = function() { return handleError(function (arg0) {\n        getObject(arg0).close();\n    }, arguments) };\n    imports.wbg.__wbg_removeEventListener_92cb9b3943463338 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        getObject(arg0).removeEventListener(getStringFromWasm0(arg1, arg2), getObject(arg3));\n    }, arguments) };\n    imports.wbg.__wbg_newwitheventinitdict_c939a6b964db4d91 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new CloseEvent(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_dispatchEvent_63c0c01600a98fd2 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).dispatchEvent(getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_url_5f6dc4009ac5f99d = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_newwithstrandinit_3fd6fba4083ff2d0 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_closure_wrapper1302 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 80, __wbg_adapter_46);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper1306 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 80, __wbg_adapter_49);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper1310 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 80, __wbg_adapter_49);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper1312 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 80, __wbg_adapter_49);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper1321 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 80, __wbg_adapter_46);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper8506 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 80, __wbg_adapter_49);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper8530 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 80, __wbg_adapter_49);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n    imports.wbg.memory = maybe_memory || new WebAssembly.Memory({initial:27,maximum:16384,shared:true});\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat64Memory0 = null;\n    cachedInt32Memory0 = null;\n    cachedUint32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module, maybe_memory) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports, maybe_memory);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input, maybe_memory) {\n    if (wasm !== undefined) return wasm;\n\n    if (typeof input === 'undefined') {\n        input = new URL(/* asset import */ __webpack_require__(/*! nillion_client_js_browser_bg.wasm */ \"./node_modules/nillion-client-browser/nillion_client_js_browser_bg.wasm\"), __webpack_require__.b);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports, maybe_memory);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__wbg_init);\n\n\n//# sourceURL=webpack://fun-with-js/./node_modules/nillion-client-browser/nillion_client_js_browser.js?");

/***/ }),

/***/ "./node_modules/nillion-client-browser/snippets/libp2p-wasm-ext-7e5f5edb880ee0f5/src/websockets.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/nillion-client-browser/snippets/libp2p-wasm-ext-7e5f5edb880ee0f5/src/websockets.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   websocket_transport: () => (/* binding */ websocket_transport)\n/* harmony export */ });\n// Copyright 2020 Parity Technologies (UK) Ltd.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n\nconst websocket_transport = () => {\n\treturn {\n\t\tdial: dial,\n\t\tlisten_on: (addr) => {\n\t\t\tlet err = new Error(\"Listening on WebSockets is not possible from within a browser\");\n\t\t\terr.name = \"NotSupportedError\";\n\t\t\tthrow err;\n\t\t},\n\t};\n}\n\n/// Turns a string multiaddress into a WebSockets string URL.\nconst multiaddr_to_ws = (addr) => {\n\tlet parsed = addr.match(/^\\/(ip4|ip6|dns4|dns6|dns)\\/(.*?)\\/tcp\\/(.*?)\\/(ws|wss|x-parity-ws\\/(.*)|x-parity-wss\\/(.*))(|\\/p2p\\/[a-zA-Z0-9]+)$/);\n\tif (parsed != null) {\n\t\tlet proto = 'wss';\n\t\tif (parsed[4] == 'ws' || parsed[4].startsWith('x-parity-ws/')) {\n\t\t\tproto = 'ws';\n\t\t}\n\t\tlet url = decodeURIComponent(parsed[5] || parsed[6] || '');\n\t\tif (parsed[1] == 'ip6') {\n\t\t\treturn proto + \"://[\" + parsed[2] + \"]:\" + parsed[3] + url;\n\t\t} else {\n\t\t\treturn proto + \"://\" + parsed[2] + \":\" + parsed[3] + url;\n\t\t}\n\t}\n\n\tlet err = new Error(\"Address not supported: \" + addr);\n\terr.name = \"NotSupportedError\";\n\tthrow err;\n}\n\n// Attempt to dial a multiaddress.\nconst dial = (addr) => {\n\tlet ws = new WebSocket(multiaddr_to_ws(addr));\n\tws.binaryType = \"arraybuffer\";\n\tlet reader = read_queue();\n\n\treturn new Promise((open_resolve, open_reject) => {\n\t\tws.onerror = (ev) => {\n\t\t\t// If `open_resolve` has been called earlier, calling `open_reject` seems to be\n\t\t\t// silently ignored. It is easier to unconditionally call `open_reject` rather than\n\t\t\t// check in which state the connection is, which would be error-prone.\n\t\t\topen_reject(ev);\n\t\t\t// Injecting an EOF is how we report to the reading side that the connection has been\n\t\t\t// closed. Injecting multiple EOFs is harmless.\n\t\t\treader.inject_eof();\n\t\t};\n\t\tws.onclose = (ev) => {\n\t\t\t// Same remarks as above.\n\t\t\topen_reject(ev);\n\t\t\treader.inject_eof();\n\t\t};\n\n\t\t// We inject all incoming messages into the queue unconditionally. The caller isn't\n\t\t// supposed to access this queue unless the connection is open.\n\t\tws.onmessage = (ev) => reader.inject_array_buffer(ev.data);\n\n\t\tws.onopen = () => open_resolve({\n\t\t\tread: (function*() { while(ws.readyState == 1) { yield reader.next(); } })(),\n\t\t\twrite: (data) => {\n\t\t\t\tif (ws.readyState == 1) {\n\t\t\t\t\t// The passed in `data` is an `ArrayBufferView` [0]. If the\n\t\t\t\t\t// underlying typed array is a `SharedArrayBuffer` (when\n\t\t\t\t\t// using WASM threads, so multiple web workers sharing\n\t\t\t\t\t// memory) the WebSocket's `send` method errors [1][2][3].\n\t\t\t\t\t// This limitation will probably be lifted in the future,\n\t\t\t\t\t// but for now we have to make a copy here ..\n\t\t\t\t\t//\n\t\t\t\t\t// [0]: https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView\n\t\t\t\t\t// [1]: https://chromium.googlesource.com/chromium/src/+/1438f63f369fed3766fa5031e7a252c986c69be6%5E%21/\n\t\t\t\t\t// [2]: https://bugreports.qt.io/browse/QTBUG-78078\n\t\t\t\t\t// [3]: https://chromium.googlesource.com/chromium/src/+/HEAD/third_party/blink/renderer/bindings/IDLExtendedAttributes.md#AllowShared_p\n\t\t\t\t\tws.send(data.slice(0));\n\t\t\t\t\treturn promise_when_send_finished(ws);\n\t\t\t\t} else {\n\t\t\t\t\treturn Promise.reject(\"WebSocket is closed\");\n\t\t\t\t}\n\t\t\t},\n\t\t\tshutdown: () => ws.close(),\n\t\t\tclose: () => {}\n\t\t});\n\t});\n}\n\n// Takes a WebSocket object and returns a Promise that resolves when bufferedAmount is low enough\n// to allow more data to be sent.\nconst promise_when_send_finished = (ws) => {\n\treturn new Promise((resolve, reject) => {\n\t\tfunction check() {\n\t\t\tif (ws.readyState != 1) {\n\t\t\t\treject(\"WebSocket is closed\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We put an arbitrary threshold of 8 kiB of buffered data.\n\t\t\tif (ws.bufferedAmount < 8 * 1024) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tsetTimeout(check, 100);\n\t\t\t}\n\t\t}\n\n\t\tcheck();\n\t})\n}\n\n// Creates a queue reading system.\nconst read_queue = () => {\n\t// State of the queue.\n\tlet state = {\n\t\t// Array of promises resolving to `ArrayBuffer`s, that haven't been transmitted back with\n\t\t// `next` yet.\n\t\tqueue: new Array(),\n\t\t// If `resolve` isn't null, it is a \"resolve\" function of a promise that has already been\n\t\t// returned by `next`. It should be called with some data.\n\t\tresolve: null,\n\t};\n\n\treturn {\n\t\t// Inserts a new Blob in the queue.\n\t\tinject_array_buffer: (buffer) => {\n\t\t\tif (state.resolve != null) {\n\t\t\t\tstate.resolve(buffer);\n\t\t\t\tstate.resolve = null;\n\t\t\t} else {\n\t\t\t\tstate.queue.push(Promise.resolve(buffer));\n\t\t\t}\n\t\t},\n\n\t\t// Inserts an EOF message in the queue.\n\t\tinject_eof: () => {\n\t\t\tif (state.resolve != null) {\n\t\t\t\tstate.resolve(null);\n\t\t\t\tstate.resolve = null;\n\t\t\t} else {\n\t\t\t\tstate.queue.push(Promise.resolve(null));\n\t\t\t}\n\t\t},\n\n\t\t// Returns a Promise that yields the next entry as an ArrayBuffer.\n\t\tnext: () => {\n\t\t\tif (state.queue.length != 0) {\n\t\t\t\treturn state.queue.shift(0);\n\t\t\t} else {\n\t\t\t\tif (state.resolve !== null)\n\t\t\t\t\tthrow \"Internal error: already have a pending promise\";\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tstate.resolve = resolve;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n};\n\n\n//# sourceURL=webpack://fun-with-js/./node_modules/nillion-client-browser/snippets/libp2p-wasm-ext-7e5f5edb880ee0f5/src/websockets.js?");

/***/ }),

/***/ "./node_modules/nillion-client-browser/snippets/nillion-client-js-browser-b8df49adba379ed0/dist/nilffi.bundle.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/nillion-client-browser/snippets/nillion-client-js-browser-b8df49adba379ed0/dist/nilffi.bundle.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MsgPayFor: () => (/* binding */ MsgPayFor),\n/* harmony export */   createPaymentsMessage: () => (/* binding */ createPaymentsMessage)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// node_modules/cosmjs-types/utf8.js\nvar require_utf8 = __commonJS({\n  \"node_modules/cosmjs-types/utf8.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.utf8Write = exports.utf8Read = exports.utf8Length = void 0;\n    function utf8Length(str) {\n      let len = 0, c = 0;\n      for (let i = 0; i < str.length; ++i) {\n        c = str.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (str.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    }\n    exports.utf8Length = utf8Length;\n    function utf8Read(buffer, start, end) {\n      const len = end - start;\n      if (len < 1)\n        return \"\";\n      const chunk = [];\n      let parts = [], i = 0, t;\n      while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode(...chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode(...chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode(...chunk.slice(0, i));\n    }\n    exports.utf8Read = utf8Read;\n    function utf8Write(str, buffer, offset) {\n      const start = offset;\n      let c1, c2;\n      for (let i = 0; i < str.length; ++i) {\n        c1 = str.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = str.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    }\n    exports.utf8Write = utf8Write;\n  }\n});\n\n// node_modules/cosmjs-types/varint.js\nvar require_varint = __commonJS({\n  \"node_modules/cosmjs-types/varint.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.writeByte = exports.writeFixed32 = exports.int64Length = exports.writeVarint64 = exports.writeVarint32 = exports.readInt32 = exports.readUInt32 = exports.zzDecode = exports.zzEncode = exports.varint32read = exports.varint32write = exports.uInt64ToString = exports.int64ToString = exports.int64FromString = exports.varint64write = exports.varint64read = void 0;\n    function varint64read() {\n      let lowBits = 0;\n      let highBits = 0;\n      for (let shift = 0; shift < 28; shift += 7) {\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 127) << shift;\n        if ((b & 128) == 0) {\n          this.assertBounds();\n          return [lowBits, highBits];\n        }\n      }\n      let middleByte = this.buf[this.pos++];\n      lowBits |= (middleByte & 15) << 28;\n      highBits = (middleByte & 112) >> 4;\n      if ((middleByte & 128) == 0) {\n        this.assertBounds();\n        return [lowBits, highBits];\n      }\n      for (let shift = 3; shift <= 31; shift += 7) {\n        let b = this.buf[this.pos++];\n        highBits |= (b & 127) << shift;\n        if ((b & 128) == 0) {\n          this.assertBounds();\n          return [lowBits, highBits];\n        }\n      }\n      throw new Error(\"invalid varint\");\n    }\n    exports.varint64read = varint64read;\n    function varint64write(lo, hi, bytes) {\n      for (let i = 0; i < 28; i = i + 7) {\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 128 : shift) & 255;\n        bytes.push(byte);\n        if (!hasNext) {\n          return;\n        }\n      }\n      const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;\n      const hasMoreBits = !(hi >> 3 == 0);\n      bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);\n      if (!hasMoreBits) {\n        return;\n      }\n      for (let i = 3; i < 31; i = i + 7) {\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 128 : shift) & 255;\n        bytes.push(byte);\n        if (!hasNext) {\n          return;\n        }\n      }\n      bytes.push(hi >>> 31 & 1);\n    }\n    exports.varint64write = varint64write;\n    var TWO_PWR_32_DBL = 4294967296;\n    function int64FromString(dec) {\n      const minus = dec[0] === \"-\";\n      if (minus) {\n        dec = dec.slice(1);\n      }\n      const base = 1e6;\n      let lowBits = 0;\n      let highBits = 0;\n      function add1e6digit(begin, end) {\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        if (lowBits >= TWO_PWR_32_DBL) {\n          highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n          lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n      }\n      add1e6digit(-24, -18);\n      add1e6digit(-18, -12);\n      add1e6digit(-12, -6);\n      add1e6digit(-6);\n      return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n    }\n    exports.int64FromString = int64FromString;\n    function int64ToString(lo, hi) {\n      let bits = newBits(lo, hi);\n      const negative = bits.hi & 2147483648;\n      if (negative) {\n        bits = negate(bits.lo, bits.hi);\n      }\n      const result = uInt64ToString(bits.lo, bits.hi);\n      return negative ? \"-\" + result : result;\n    }\n    exports.int64ToString = int64ToString;\n    function uInt64ToString(lo, hi) {\n      ({ lo, hi } = toUnsigned(lo, hi));\n      if (hi <= 2097151) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n      }\n      const low = lo & 16777215;\n      const mid = (lo >>> 24 | hi << 8) & 16777215;\n      const high = hi >> 16 & 65535;\n      let digitA = low + mid * 6777216 + high * 6710656;\n      let digitB = mid + high * 8147497;\n      let digitC = high * 2;\n      const base = 1e7;\n      if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n      }\n      if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n      }\n      return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n    }\n    exports.uInt64ToString = uInt64ToString;\n    function toUnsigned(lo, hi) {\n      return { lo: lo >>> 0, hi: hi >>> 0 };\n    }\n    function newBits(lo, hi) {\n      return { lo: lo | 0, hi: hi | 0 };\n    }\n    function negate(lowBits, highBits) {\n      highBits = ~highBits;\n      if (lowBits) {\n        lowBits = ~lowBits + 1;\n      } else {\n        highBits += 1;\n      }\n      return newBits(lowBits, highBits);\n    }\n    var decimalFrom1e7WithLeadingZeros = (digit1e7) => {\n      const partial = String(digit1e7);\n      return \"0000000\".slice(partial.length) + partial;\n    };\n    function varint32write(value, bytes) {\n      if (value >= 0) {\n        while (value > 127) {\n          bytes.push(value & 127 | 128);\n          value = value >>> 7;\n        }\n        bytes.push(value);\n      } else {\n        for (let i = 0; i < 9; i++) {\n          bytes.push(value & 127 | 128);\n          value = value >> 7;\n        }\n        bytes.push(1);\n      }\n    }\n    exports.varint32write = varint32write;\n    function varint32read() {\n      let b = this.buf[this.pos++];\n      let result = b & 127;\n      if ((b & 128) == 0) {\n        this.assertBounds();\n        return result;\n      }\n      b = this.buf[this.pos++];\n      result |= (b & 127) << 7;\n      if ((b & 128) == 0) {\n        this.assertBounds();\n        return result;\n      }\n      b = this.buf[this.pos++];\n      result |= (b & 127) << 14;\n      if ((b & 128) == 0) {\n        this.assertBounds();\n        return result;\n      }\n      b = this.buf[this.pos++];\n      result |= (b & 127) << 21;\n      if ((b & 128) == 0) {\n        this.assertBounds();\n        return result;\n      }\n      b = this.buf[this.pos++];\n      result |= (b & 15) << 28;\n      for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)\n        b = this.buf[this.pos++];\n      if ((b & 128) != 0)\n        throw new Error(\"invalid varint\");\n      this.assertBounds();\n      return result >>> 0;\n    }\n    exports.varint32read = varint32read;\n    function zzEncode(lo, hi) {\n      let mask = hi >> 31;\n      hi = ((hi << 1 | lo >>> 31) ^ mask) >>> 0;\n      lo = (lo << 1 ^ mask) >>> 0;\n      return [lo, hi];\n    }\n    exports.zzEncode = zzEncode;\n    function zzDecode(lo, hi) {\n      let mask = -(lo & 1);\n      lo = ((lo >>> 1 | hi << 31) ^ mask) >>> 0;\n      hi = (hi >>> 1 ^ mask) >>> 0;\n      return [lo, hi];\n    }\n    exports.zzDecode = zzDecode;\n    function readUInt32(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;\n    }\n    exports.readUInt32 = readUInt32;\n    function readInt32(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);\n    }\n    exports.readInt32 = readInt32;\n    function writeVarint32(val, buf, pos) {\n      while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n      }\n      buf[pos] = val;\n    }\n    exports.writeVarint32 = writeVarint32;\n    function writeVarint64(val, buf, pos) {\n      while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n      }\n      while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n      }\n      buf[pos++] = val.lo;\n    }\n    exports.writeVarint64 = writeVarint64;\n    function int64Length(lo, hi) {\n      let part0 = lo, part1 = (lo >>> 28 | hi << 4) >>> 0, part2 = hi >>> 24;\n      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n    }\n    exports.int64Length = int64Length;\n    function writeFixed32(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    exports.writeFixed32 = writeFixed32;\n    function writeByte(val, buf, pos) {\n      buf[pos] = val & 255;\n    }\n    exports.writeByte = writeByte;\n  }\n});\n\n// node_modules/cosmjs-types/binary.js\nvar require_binary = __commonJS({\n  \"node_modules/cosmjs-types/binary.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.BinaryWriter = exports.BinaryReader = exports.WireType = void 0;\n    var utf8_1 = require_utf8();\n    var varint_1 = require_varint();\n    var WireType;\n    (function(WireType2) {\n      WireType2[WireType2[\"Varint\"] = 0] = \"Varint\";\n      WireType2[WireType2[\"Fixed64\"] = 1] = \"Fixed64\";\n      WireType2[WireType2[\"Bytes\"] = 2] = \"Bytes\";\n      WireType2[WireType2[\"Fixed32\"] = 5] = \"Fixed32\";\n    })(WireType || (exports.WireType = WireType = {}));\n    var BinaryReader2 = class {\n      assertBounds() {\n        if (this.pos > this.len)\n          throw new RangeError(\"premature EOF\");\n      }\n      constructor(buf) {\n        this.buf = buf ? new Uint8Array(buf) : new Uint8Array(0);\n        this.pos = 0;\n        this.type = 0;\n        this.len = this.buf.length;\n      }\n      tag() {\n        const tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5)\n          throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [fieldNo, wireType, tag];\n      }\n      skip(length) {\n        if (typeof length === \"number\") {\n          if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n          this.pos += length;\n        } else {\n          do {\n            if (this.pos >= this.len)\n              throw indexOutOfRange(this);\n          } while (this.buf[this.pos++] & 128);\n        }\n        return this;\n      }\n      skipType(wireType) {\n        switch (wireType) {\n          case WireType.Varint:\n            this.skip();\n            break;\n          case WireType.Fixed64:\n            this.skip(8);\n            break;\n          case WireType.Bytes:\n            this.skip(this.uint32());\n            break;\n          case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n              this.skipType(wireType);\n            }\n            break;\n          case WireType.Fixed32:\n            this.skip(4);\n            break;\n          default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n        }\n        return this;\n      }\n      uint32() {\n        return varint_1.varint32read.bind(this)();\n      }\n      int32() {\n        return this.uint32() | 0;\n      }\n      sint32() {\n        const num = this.uint32();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2;\n      }\n      fixed32() {\n        const val = (0, varint_1.readUInt32)(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n      }\n      sfixed32() {\n        const val = (0, varint_1.readInt32)(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n      }\n      int64() {\n        const [lo, hi] = varint_1.varint64read.bind(this)();\n        return BigInt((0, varint_1.int64ToString)(lo, hi));\n      }\n      uint64() {\n        const [lo, hi] = varint_1.varint64read.bind(this)();\n        return BigInt((0, varint_1.uInt64ToString)(lo, hi));\n      }\n      sint64() {\n        let [lo, hi] = varint_1.varint64read.bind(this)();\n        [lo, hi] = (0, varint_1.zzDecode)(lo, hi);\n        return BigInt((0, varint_1.int64ToString)(lo, hi));\n      }\n      fixed64() {\n        const lo = this.sfixed32();\n        const hi = this.sfixed32();\n        return BigInt((0, varint_1.uInt64ToString)(lo, hi));\n      }\n      sfixed64() {\n        const lo = this.sfixed32();\n        const hi = this.sfixed32();\n        return BigInt((0, varint_1.int64ToString)(lo, hi));\n      }\n      float() {\n        throw new Error(\"float not supported\");\n      }\n      double() {\n        throw new Error(\"double not supported\");\n      }\n      bool() {\n        const [lo, hi] = varint_1.varint64read.bind(this)();\n        return lo !== 0 || hi !== 0;\n      }\n      bytes() {\n        const len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n      }\n      string() {\n        const bytes = this.bytes();\n        return (0, utf8_1.utf8Read)(bytes, 0, bytes.length);\n      }\n    };\n    exports.BinaryReader = BinaryReader2;\n    var Op = class {\n      constructor(fn, len, val) {\n        this.fn = fn;\n        this.len = len;\n        this.val = val;\n      }\n      proceed(buf, pos) {\n        if (this.fn) {\n          this.fn(this.val, buf, pos);\n        }\n      }\n    };\n    var State = class {\n      constructor(writer) {\n        this.head = writer.head;\n        this.tail = writer.tail;\n        this.len = writer.len;\n        this.next = writer.states;\n      }\n    };\n    var BinaryWriter2 = class _BinaryWriter {\n      constructor() {\n        this.len = 0;\n        this.uint64 = _BinaryWriter.prototype.int64;\n        this.sfixed64 = _BinaryWriter.prototype.fixed64;\n        this.sfixed32 = _BinaryWriter.prototype.fixed32;\n        this.head = new Op(null, 0, 0);\n        this.tail = this.head;\n        this.states = null;\n      }\n      static create() {\n        return new _BinaryWriter();\n      }\n      static alloc(size) {\n        if (typeof Uint8Array !== \"undefined\") {\n          return pool((size2) => new Uint8Array(size2), Uint8Array.prototype.subarray)(size);\n        } else {\n          return new Array(size);\n        }\n      }\n      _push(fn, len, val) {\n        this.tail = this.tail.next = new Op(fn, len, val);\n        this.len += len;\n        return this;\n      }\n      finish() {\n        let head = this.head.next, pos = 0;\n        const buf = _BinaryWriter.alloc(this.len);\n        while (head) {\n          head.proceed(buf, pos);\n          pos += head.len;\n          head = head.next;\n        }\n        return buf;\n      }\n      fork() {\n        this.states = new State(this);\n        this.head = this.tail = new Op(null, 0, 0);\n        this.len = 0;\n        return this;\n      }\n      reset() {\n        if (this.states) {\n          this.head = this.states.head;\n          this.tail = this.states.tail;\n          this.len = this.states.len;\n          this.states = this.states.next;\n        } else {\n          this.head = this.tail = new Op(null, 0, 0);\n          this.len = 0;\n        }\n        return this;\n      }\n      ldelim() {\n        const head = this.head, tail = this.tail, len = this.len;\n        this.reset().uint32(len);\n        if (len) {\n          this.tail.next = head.next;\n          this.tail = tail;\n          this.len += len;\n        }\n        return this;\n      }\n      tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n      }\n      uint32(value) {\n        this.len += (this.tail = this.tail.next = new Op(varint_1.writeVarint32, (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n        return this;\n      }\n      int32(value) {\n        return value < 0 ? this._push(varint_1.writeVarint64, 10, (0, varint_1.int64FromString)(value.toString())) : this.uint32(value);\n      }\n      sint32(value) {\n        return this.uint32((value << 1 ^ value >> 31) >>> 0);\n      }\n      int64(value) {\n        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());\n        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), { lo, hi });\n      }\n      sint64(value) {\n        let { lo, hi } = (0, varint_1.int64FromString)(value.toString());\n        [lo, hi] = (0, varint_1.zzEncode)(lo, hi);\n        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo, hi), { lo, hi });\n      }\n      fixed64(value) {\n        const { lo, hi } = (0, varint_1.int64FromString)(value.toString());\n        return this._push(varint_1.writeFixed32, 4, lo)._push(varint_1.writeFixed32, 4, hi);\n      }\n      bool(value) {\n        return this._push(varint_1.writeByte, 1, value ? 1 : 0);\n      }\n      fixed32(value) {\n        return this._push(varint_1.writeFixed32, 4, value >>> 0);\n      }\n      float(value) {\n        throw new Error(\"float not supported\" + value);\n      }\n      double(value) {\n        throw new Error(\"double not supported\" + value);\n      }\n      bytes(value) {\n        const len = value.length >>> 0;\n        if (!len)\n          return this._push(varint_1.writeByte, 1, 0);\n        return this.uint32(len)._push(writeBytes, len, value);\n      }\n      string(value) {\n        const len = (0, utf8_1.utf8Length)(value);\n        return len ? this.uint32(len)._push(utf8_1.utf8Write, len, value) : this._push(varint_1.writeByte, 1, 0);\n      }\n    };\n    exports.BinaryWriter = BinaryWriter2;\n    function writeBytes(val, buf, pos) {\n      if (typeof Uint8Array !== \"undefined\") {\n        buf.set(val, pos);\n      } else {\n        for (let i = 0; i < val.length; ++i)\n          buf[pos + i] = val[i];\n      }\n    }\n    function pool(alloc, slice, size) {\n      const SIZE = size || 8192;\n      const MAX = SIZE >>> 1;\n      let slab = null;\n      let offset = SIZE;\n      return function pool_alloc(size2) {\n        if (size2 < 1 || size2 > MAX)\n          return alloc(size2);\n        if (offset + size2 > SIZE) {\n          slab = alloc(SIZE);\n          offset = 0;\n        }\n        const buf = slice.call(slab, offset, offset += size2);\n        if (offset & 7)\n          offset = (offset | 7) + 1;\n        return buf;\n      };\n    }\n    function indexOutOfRange(reader, writeLength) {\n      return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n    }\n  }\n});\n\n// node_modules/cosmjs-types/helpers.js\nvar require_helpers = __commonJS({\n  \"node_modules/cosmjs-types/helpers.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.fromJsonTimestamp = exports.fromTimestamp = exports.toTimestamp = exports.setPaginationParams = exports.isObject = exports.isSet = exports.fromDuration = exports.toDuration = exports.omitDefault = exports.base64FromBytes = exports.bytesFromBase64 = void 0;\n    var globalThis = (() => {\n      if (typeof globalThis !== \"undefined\")\n        return globalThis;\n      if (typeof self !== \"undefined\")\n        return self;\n      if (typeof window !== \"undefined\")\n        return window;\n      if (typeof __webpack_require__.g !== \"undefined\")\n        return __webpack_require__.g;\n      throw \"Unable to locate global object\";\n    })();\n    var atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\n    function bytesFromBase64(b64) {\n      const bin = atob(b64);\n      const arr = new Uint8Array(bin.length);\n      for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n      }\n      return arr;\n    }\n    exports.bytesFromBase64 = bytesFromBase64;\n    var btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\n    function base64FromBytes(arr) {\n      const bin = [];\n      arr.forEach((byte) => {\n        bin.push(String.fromCharCode(byte));\n      });\n      return btoa(bin.join(\"\"));\n    }\n    exports.base64FromBytes = base64FromBytes;\n    function omitDefault(input) {\n      if (typeof input === \"string\") {\n        return input === \"\" ? void 0 : input;\n      }\n      if (typeof input === \"number\") {\n        return input === 0 ? void 0 : input;\n      }\n      if (typeof input === \"bigint\") {\n        return input === BigInt(0) ? void 0 : input;\n      }\n      throw new Error(`Got unsupported type ${typeof input}`);\n    }\n    exports.omitDefault = omitDefault;\n    function toDuration(duration) {\n      return {\n        seconds: BigInt(Math.floor(parseInt(duration) / 1e9)),\n        nanos: parseInt(duration) % 1e9\n      };\n    }\n    exports.toDuration = toDuration;\n    function fromDuration(duration) {\n      return (parseInt(duration.seconds.toString()) * 1e9 + duration.nanos).toString();\n    }\n    exports.fromDuration = fromDuration;\n    function isSet2(value) {\n      return value !== null && value !== void 0;\n    }\n    exports.isSet = isSet2;\n    function isObject(value) {\n      return typeof value === \"object\" && value !== null;\n    }\n    exports.isObject = isObject;\n    var setPaginationParams = (options, pagination) => {\n      if (!pagination) {\n        return options;\n      }\n      if (typeof pagination?.countTotal !== \"undefined\") {\n        options.params[\"pagination.count_total\"] = pagination.countTotal;\n      }\n      if (typeof pagination?.key !== \"undefined\") {\n        options.params[\"pagination.key\"] = Buffer.from(pagination.key).toString(\"base64\");\n      }\n      if (typeof pagination?.limit !== \"undefined\") {\n        options.params[\"pagination.limit\"] = pagination.limit.toString();\n      }\n      if (typeof pagination?.offset !== \"undefined\") {\n        options.params[\"pagination.offset\"] = pagination.offset.toString();\n      }\n      if (typeof pagination?.reverse !== \"undefined\") {\n        options.params[\"pagination.reverse\"] = pagination.reverse;\n      }\n      return options;\n    };\n    exports.setPaginationParams = setPaginationParams;\n    function toTimestamp(date) {\n      const seconds = numberToLong(date.getTime() / 1e3);\n      const nanos = date.getTime() % 1e3 * 1e6;\n      return {\n        seconds,\n        nanos\n      };\n    }\n    exports.toTimestamp = toTimestamp;\n    function fromTimestamp(t) {\n      let millis = Number(t.seconds) * 1e3;\n      millis += t.nanos / 1e6;\n      return new Date(millis);\n    }\n    exports.fromTimestamp = fromTimestamp;\n    var timestampFromJSON = (object) => {\n      return {\n        seconds: isSet2(object.seconds) ? BigInt(object.seconds.toString()) : BigInt(0),\n        nanos: isSet2(object.nanos) ? Number(object.nanos) : 0\n      };\n    };\n    function fromJsonTimestamp(o) {\n      if (o instanceof Date) {\n        return toTimestamp(o);\n      } else if (typeof o === \"string\") {\n        return toTimestamp(new Date(o));\n      } else {\n        return timestampFromJSON(o);\n      }\n    }\n    exports.fromJsonTimestamp = fromJsonTimestamp;\n    function numberToLong(number) {\n      return BigInt(Math.trunc(number));\n    }\n  }\n});\n\n// node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js\nvar require_coin = __commonJS({\n  \"node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.DecProto = exports.IntProto = exports.DecCoin = exports.Coin = exports.protobufPackage = void 0;\n    var binary_1 = require_binary();\n    var helpers_1 = require_helpers();\n    exports.protobufPackage = \"cosmos.base.v1beta1\";\n    function createBaseCoin() {\n      return {\n        denom: \"\",\n        amount: \"\"\n      };\n    }\n    exports.Coin = {\n      typeUrl: \"/cosmos.base.v1beta1.Coin\",\n      encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.denom !== \"\") {\n          writer.uint32(10).string(message.denom);\n        }\n        if (message.amount !== \"\") {\n          writer.uint32(18).string(message.amount);\n        }\n        return writer;\n      },\n      decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === void 0 ? reader.len : reader.pos + length;\n        const message = createBaseCoin();\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              message.denom = reader.string();\n              break;\n            case 2:\n              message.amount = reader.string();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      },\n      fromJSON(object) {\n        const obj = createBaseCoin();\n        if ((0, helpers_1.isSet)(object.denom))\n          obj.denom = String(object.denom);\n        if ((0, helpers_1.isSet)(object.amount))\n          obj.amount = String(object.amount);\n        return obj;\n      },\n      toJSON(message) {\n        const obj = {};\n        message.denom !== void 0 && (obj.denom = message.denom);\n        message.amount !== void 0 && (obj.amount = message.amount);\n        return obj;\n      },\n      fromPartial(object) {\n        const message = createBaseCoin();\n        message.denom = object.denom ?? \"\";\n        message.amount = object.amount ?? \"\";\n        return message;\n      }\n    };\n    function createBaseDecCoin() {\n      return {\n        denom: \"\",\n        amount: \"\"\n      };\n    }\n    exports.DecCoin = {\n      typeUrl: \"/cosmos.base.v1beta1.DecCoin\",\n      encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.denom !== \"\") {\n          writer.uint32(10).string(message.denom);\n        }\n        if (message.amount !== \"\") {\n          writer.uint32(18).string(message.amount);\n        }\n        return writer;\n      },\n      decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === void 0 ? reader.len : reader.pos + length;\n        const message = createBaseDecCoin();\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              message.denom = reader.string();\n              break;\n            case 2:\n              message.amount = reader.string();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      },\n      fromJSON(object) {\n        const obj = createBaseDecCoin();\n        if ((0, helpers_1.isSet)(object.denom))\n          obj.denom = String(object.denom);\n        if ((0, helpers_1.isSet)(object.amount))\n          obj.amount = String(object.amount);\n        return obj;\n      },\n      toJSON(message) {\n        const obj = {};\n        message.denom !== void 0 && (obj.denom = message.denom);\n        message.amount !== void 0 && (obj.amount = message.amount);\n        return obj;\n      },\n      fromPartial(object) {\n        const message = createBaseDecCoin();\n        message.denom = object.denom ?? \"\";\n        message.amount = object.amount ?? \"\";\n        return message;\n      }\n    };\n    function createBaseIntProto() {\n      return {\n        int: \"\"\n      };\n    }\n    exports.IntProto = {\n      typeUrl: \"/cosmos.base.v1beta1.IntProto\",\n      encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.int !== \"\") {\n          writer.uint32(10).string(message.int);\n        }\n        return writer;\n      },\n      decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === void 0 ? reader.len : reader.pos + length;\n        const message = createBaseIntProto();\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              message.int = reader.string();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      },\n      fromJSON(object) {\n        const obj = createBaseIntProto();\n        if ((0, helpers_1.isSet)(object.int))\n          obj.int = String(object.int);\n        return obj;\n      },\n      toJSON(message) {\n        const obj = {};\n        message.int !== void 0 && (obj.int = message.int);\n        return obj;\n      },\n      fromPartial(object) {\n        const message = createBaseIntProto();\n        message.int = object.int ?? \"\";\n        return message;\n      }\n    };\n    function createBaseDecProto() {\n      return {\n        dec: \"\"\n      };\n    }\n    exports.DecProto = {\n      typeUrl: \"/cosmos.base.v1beta1.DecProto\",\n      encode(message, writer = binary_1.BinaryWriter.create()) {\n        if (message.dec !== \"\") {\n          writer.uint32(10).string(message.dec);\n        }\n        return writer;\n      },\n      decode(input, length) {\n        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);\n        let end = length === void 0 ? reader.len : reader.pos + length;\n        const message = createBaseDecProto();\n        while (reader.pos < end) {\n          const tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              message.dec = reader.string();\n              break;\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      },\n      fromJSON(object) {\n        const obj = createBaseDecProto();\n        if ((0, helpers_1.isSet)(object.dec))\n          obj.dec = String(object.dec);\n        return obj;\n      },\n      toJSON(message) {\n        const obj = {};\n        message.dec !== void 0 && (obj.dec = message.dec);\n        return obj;\n      },\n      fromPartial(object) {\n        const message = createBaseDecProto();\n        message.dec = object.dec ?? \"\";\n        return message;\n      }\n    };\n  }\n});\n\n// src/ts/lib.ts\nvar import_coin = __toESM(require_coin());\nvar import_binary = __toESM(require_binary());\nvar import_helpers = __toESM(require_helpers());\nfunction createBaseMsgPayFor() {\n  return {\n    fromAddress: \"\",\n    nonce: \"\",\n    amount: []\n  };\n}\nfunction verifyAmount(amounts) {\n  if (!Array.isArray(amounts)) return false;\n  if (amounts.length === 1) return false;\n  for (const amount of amounts) {\n    if (!amount.denom || !amount.amount) {\n      return false;\n    }\n  }\n  return true;\n}\nvar MsgPayFor = {\n  typeUrl: \"/cosmos.staking.v1beta1.MsgPayFor\",\n  encode(message, writer = import_binary.BinaryWriter.create()) {\n    if (message.fromAddress !== \"\") {\n      writer.uint32(10).string(message.fromAddress);\n    }\n    if (message.nonce !== \"\") {\n      writer.uint32(18).string(message.nonce);\n    }\n    if (verifyAmount(message.amount)) {\n      import_coin.Coin.encode(message.amount[0], writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof import_binary.BinaryReader ? input : new import_binary.BinaryReader(input);\n    let end = length === void 0 ? reader.len : reader.pos + length;\n    const message = createBaseMsgPayFor();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.fromAddress = reader.string();\n          break;\n        case 2:\n          message.nonce = reader.string();\n          break;\n        case 3:\n          message.amount = [import_coin.Coin.decode(reader, reader.uint32())];\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const obj = createBaseMsgPayFor();\n    if ((0, import_helpers.isSet)(object.fromAddress)) obj.fromAddress = String(object.fromAddress);\n    if ((0, import_helpers.isSet)(object.nonce)) obj.nonce = String(object.nonce);\n    if (Array.isArray(object.amount))\n      obj.amount = obj.amount.map(import_coin.Coin.fromJSON);\n    return obj;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);\n    message.nonce !== void 0 && (obj.nonce = message.nonce);\n    message.amount !== void 0 && Array.isArray(message.amount) && (obj.amount = message.amount ? message.amount.map(import_coin.Coin.toJSON) : void 0);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = createBaseMsgPayFor();\n    message.fromAddress = object.fromAddress ?? \"\";\n    message.nonce = object.nonce ?? \"\";\n    if (object.amount !== void 0 && object.amount !== null && Array.isArray(object.amount)) {\n      message.amount = object.amount.map(import_coin.Coin.fromPartial);\n    }\n    return message;\n  }\n};\nfunction createPaymentsMessage(quote, address, typeUrl) {\n  const msg = {\n    fromAddress: address,\n    nonce: quote.nonce,\n    amount: [\n      {\n        denom: \"\",\n        amount: quote.amount\n      }\n    ]\n  };\n  return { typeUrl, value: MsgPayFor.fromPartial(msg) };\n}\n\n\n\n//# sourceURL=webpack://fun-with-js/./node_modules/nillion-client-browser/snippets/nillion-client-js-browser-b8df49adba379ed0/dist/nilffi.bundle.js?");

/***/ }),

/***/ "./node_modules/nillion-client-browser/nillion_client_js_browser_bg.wasm":
/*!*******************************************************************************!*\
  !*** ./node_modules/nillion-client-browser/nillion_client_js_browser_bg.wasm ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"788ba5343f142dbba2ba.wasm\";\n\n//# sourceURL=webpack://fun-with-js/./node_modules/nillion-client-browser/nillion_client_js_browser_bg.wasm?");

/***/ })

}]);